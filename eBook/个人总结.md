<!--
 * @Author: GiddyPoet
 * @Date: 2021-12-31 14:58:53
 * @LastEditTime: 2021-12-31 15:37:25
 * @Description: 
-->


## GO相关细节和技巧总结


### 变量和指针
* 如果方法是通过指针作为接受者实现的，则变量就无法调用该方法，这种情况在rpc，handler等调用的时候会报错。
* 反之，如果是通过变量实现的该方法，则可以通过指针，原理是GO可以实现自动的指针解引用


### 如何判断interface类型和如何判断一个类型是否实现了该接口

通过`v.(type)`判断interface类型,同样可以通过`reflect`实现，这里不再赘述。
```go
func checkType(v interface{}) {
    switch v.(type) {
        case int:
        // 
        case string:
        // 
    }
}
```

通过`v.(interface)`判断是否实现了interface接口
```go
type Instance interface{
    Speak()
}

type Cat struct {
}

func checkInterface(v interface{}) {
    if _,ok :=v.(Instance);ok {
        fmt.Println("Interface instance")
    }
}
```

### 闭包
闭包的核心就是函数和环境，具体地说，在实际中引用环境是指外部函数的环境，闭包保存/记录了它产生时的外部函数的所有环境。
闭包规则：
1. 实际要看传递的值采用的是值还是指针，如果传递是的值，则对外封闭，不能通过修改传进去的那个变量来起到修改闭包值的目的，如果是指针，则可以通过修改变量值来修改。

```go
func foo1(x *int) func() {
    return func() {
        *x = *x + 1
        fmt.Printf("foo1 val = %d\n", *x)
    }
}
func foo2(x int) func() {
    return func() {
        x = x + 1
        fmt.Printf("foo1 val = %d\n", x)
    }
}
​
// Q1第一组实验
x := 133
f1 := foo1(&x) 
f2 := foo2(x)
f1()  134 x=134
f2()  134 
f1()  135 x=135
f2()  135
// Q1第二组
x = 233 // f1不对外封闭
f1()  234 x=233
f2()  136
f1()  235 x=235
f2()  137
// Q1第三组
foo1(&x)() 236 x=236
foo2(x)() 237
foo1(&x)() 237 x=237
foo2(x)()  238
```

2. 闭包延迟绑定，在执行的时候去外部环境寻找最新的数值

```go
func foo7(x int) []func() {
    var fs []func()
    values := []int{1, 2, 3, 5}
    for _, val := range values {
        fs = append(fs, func() {
            fmt.Printf("foo7 val = %d\n", x+val)
        })
    }
    return fs
}
// Q4实验：
f7s := foo7(11)
for _, f7 := range f7s {
    f7()
}

// 延迟绑定只会取到5，所以5+11=16
```

3. Go Routine的延迟绑定，同闭包的延迟绑定，但是会延长变量的生命周期

### defer的4大原则

在此先强调一下，如果进程以`os.Exit()`的方式退出，则不会执行`defer`函数

* `defer`后面必须是函数或者方法调用，不能加括号
* `defer`参数绑定的时候是在函数调用的时候，进行绑定的
* LIFO原则，最先调用的defer最后出
* 被`defer`的函数可以对defer语句所在的函数的命名返回值做读取和修改操作。

```golang
func f() (result int) {
	defer func() {
		// result is accessed after it was set to 6 by the return statement
		result *= 7
	}()
	return 6
}
```
    上例中，被defer的函数func对defer语句所在的函数f的命名返回值result做了修改操作。执行顺序是函数f先把要返回的值6赋值给result，然后执行被defer的函数func，result被修改为42，然后函数f返回result，也就是返回了42。


### GO有引用变量和引用传递吗？

先说答案：GO没有引用，但是GO是通过指针传递来处理的，简单来说map、slice和channel类型都是通过指针传递实现的。

特别说明的，上述变量是指向runtime的指针。

### new make的区别

都清楚就不赘述了。

* 为什么针对slice、map和chan专门定义一个make函数？
  * 上述类型底层结构类型要求在使用的时候必须初始化，如果不初始化其值就是nil，则会引发下述问题：
    * map如果是nil，无法插入元素，会引发panic
    * chan如果是nil，往chan发送数据和接受数据都会阻塞
    * slice实际上为nil，是可以通过append函数调用的，因为append对slice做了处理，但是我们一般不这样使用。
* 为什么slic是nil也可以直接append
  * 对于nil slice，append会对slice的底层数组做扩容，通过调用mallocgc向Go的内存管理器申请内存空间，再赋值给原来的nil slice。

最佳实践：
1. 尽量不使用new
2. 对于slice,map和chan的定义和初始化，固定使用make